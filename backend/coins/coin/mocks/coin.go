// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/digitalbitbox/bitbox-wallet-app/backend/coins/coin"
	"github.com/digitalbitbox/bitbox-wallet-app/util/observable"
	"sync"
)

var (
	lockCoinMockBlockExplorerTransactionURLPrefix sync.RWMutex
	lockCoinMockClose                             sync.RWMutex
	lockCoinMockCode                              sync.RWMutex
	lockCoinMockDecimals                          sync.RWMutex
	lockCoinMockFormatAmount                      sync.RWMutex
	lockCoinMockInitialize                        sync.RWMutex
	lockCoinMockName                              sync.RWMutex
	lockCoinMockObserve                           sync.RWMutex
	lockCoinMockSmallestUnit                      sync.RWMutex
	lockCoinMockToUnit                            sync.RWMutex
	lockCoinMockUnit                              sync.RWMutex
)

// Ensure, that CoinMock does implement coin.Coin.
// If this is not the case, regenerate this file with moq.
var _ coin.Coin = &CoinMock{}

// CoinMock is a mock implementation of coin.Coin.
//
//     func TestSomethingThatUsesCoin(t *testing.T) {
//
//         // make and configure a mocked coin.Coin
//         mockedCoin := &CoinMock{
//             BlockExplorerTransactionURLPrefixFunc: func() string {
// 	               panic("mock out the BlockExplorerTransactionURLPrefix method")
//             },
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             CodeFunc: func() coin.Code {
// 	               panic("mock out the Code method")
//             },
//             DecimalsFunc: func(isFee bool) uint {
// 	               panic("mock out the Decimals method")
//             },
//             FormatAmountFunc: func(amount coin.Amount, isFee bool) string {
// 	               panic("mock out the FormatAmount method")
//             },
//             InitializeFunc: func()  {
// 	               panic("mock out the Initialize method")
//             },
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//             ObserveFunc: func(in1 func(observable.Event)) func() {
// 	               panic("mock out the Observe method")
//             },
//             SmallestUnitFunc: func() string {
// 	               panic("mock out the SmallestUnit method")
//             },
//             ToUnitFunc: func(amount coin.Amount, isFee bool) float64 {
// 	               panic("mock out the ToUnit method")
//             },
//             UnitFunc: func(isFee bool) string {
// 	               panic("mock out the Unit method")
//             },
//         }
//
//         // use mockedCoin in code that requires coin.Coin
//         // and then make assertions.
//
//     }
type CoinMock struct {
	// BlockExplorerTransactionURLPrefixFunc mocks the BlockExplorerTransactionURLPrefix method.
	BlockExplorerTransactionURLPrefixFunc func() string

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CodeFunc mocks the Code method.
	CodeFunc func() coin.Code

	// DecimalsFunc mocks the Decimals method.
	DecimalsFunc func(isFee bool) uint

	// FormatAmountFunc mocks the FormatAmount method.
	FormatAmountFunc func(amount coin.Amount, isFee bool) string

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func()

	// NameFunc mocks the Name method.
	NameFunc func() string

	// ObserveFunc mocks the Observe method.
	ObserveFunc func(in1 func(observable.Event)) func()

	// SmallestUnitFunc mocks the SmallestUnit method.
	SmallestUnitFunc func() string

	// ToUnitFunc mocks the ToUnit method.
	ToUnitFunc func(amount coin.Amount, isFee bool) float64

	// UnitFunc mocks the Unit method.
	UnitFunc func(isFee bool) string

	// calls tracks calls to the methods.
	calls struct {
		// BlockExplorerTransactionURLPrefix holds details about calls to the BlockExplorerTransactionURLPrefix method.
		BlockExplorerTransactionURLPrefix []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Code holds details about calls to the Code method.
		Code []struct {
		}
		// Decimals holds details about calls to the Decimals method.
		Decimals []struct {
			// IsFee is the isFee argument value.
			IsFee bool
		}
		// FormatAmount holds details about calls to the FormatAmount method.
		FormatAmount []struct {
			// Amount is the amount argument value.
			Amount coin.Amount
			// IsFee is the isFee argument value.
			IsFee bool
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// Observe holds details about calls to the Observe method.
		Observe []struct {
			// In1 is the in1 argument value.
			In1 func(observable.Event)
		}
		// SmallestUnit holds details about calls to the SmallestUnit method.
		SmallestUnit []struct {
		}
		// ToUnit holds details about calls to the ToUnit method.
		ToUnit []struct {
			// Amount is the amount argument value.
			Amount coin.Amount
			// IsFee is the isFee argument value.
			IsFee bool
		}
		// Unit holds details about calls to the Unit method.
		Unit []struct {
			// IsFee is the isFee argument value.
			IsFee bool
		}
	}
}

// BlockExplorerTransactionURLPrefix calls BlockExplorerTransactionURLPrefixFunc.
func (mock *CoinMock) BlockExplorerTransactionURLPrefix() string {
	if mock.BlockExplorerTransactionURLPrefixFunc == nil {
		panic("CoinMock.BlockExplorerTransactionURLPrefixFunc: method is nil but Coin.BlockExplorerTransactionURLPrefix was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockBlockExplorerTransactionURLPrefix.Lock()
	mock.calls.BlockExplorerTransactionURLPrefix = append(mock.calls.BlockExplorerTransactionURLPrefix, callInfo)
	lockCoinMockBlockExplorerTransactionURLPrefix.Unlock()
	return mock.BlockExplorerTransactionURLPrefixFunc()
}

// BlockExplorerTransactionURLPrefixCalls gets all the calls that were made to BlockExplorerTransactionURLPrefix.
// Check the length with:
//     len(mockedCoin.BlockExplorerTransactionURLPrefixCalls())
func (mock *CoinMock) BlockExplorerTransactionURLPrefixCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockBlockExplorerTransactionURLPrefix.RLock()
	calls = mock.calls.BlockExplorerTransactionURLPrefix
	lockCoinMockBlockExplorerTransactionURLPrefix.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *CoinMock) Close() error {
	if mock.CloseFunc == nil {
		panic("CoinMock.CloseFunc: method is nil but Coin.Close was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockCoinMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedCoin.CloseCalls())
func (mock *CoinMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockClose.RLock()
	calls = mock.calls.Close
	lockCoinMockClose.RUnlock()
	return calls
}

// Code calls CodeFunc.
func (mock *CoinMock) Code() coin.Code {
	if mock.CodeFunc == nil {
		panic("CoinMock.CodeFunc: method is nil but Coin.Code was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockCode.Lock()
	mock.calls.Code = append(mock.calls.Code, callInfo)
	lockCoinMockCode.Unlock()
	return mock.CodeFunc()
}

// CodeCalls gets all the calls that were made to Code.
// Check the length with:
//     len(mockedCoin.CodeCalls())
func (mock *CoinMock) CodeCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockCode.RLock()
	calls = mock.calls.Code
	lockCoinMockCode.RUnlock()
	return calls
}

// Decimals calls DecimalsFunc.
func (mock *CoinMock) Decimals(isFee bool) uint {
	if mock.DecimalsFunc == nil {
		panic("CoinMock.DecimalsFunc: method is nil but Coin.Decimals was just called")
	}
	callInfo := struct {
		IsFee bool
	}{
		IsFee: isFee,
	}
	lockCoinMockDecimals.Lock()
	mock.calls.Decimals = append(mock.calls.Decimals, callInfo)
	lockCoinMockDecimals.Unlock()
	return mock.DecimalsFunc(isFee)
}

// DecimalsCalls gets all the calls that were made to Decimals.
// Check the length with:
//     len(mockedCoin.DecimalsCalls())
func (mock *CoinMock) DecimalsCalls() []struct {
	IsFee bool
} {
	var calls []struct {
		IsFee bool
	}
	lockCoinMockDecimals.RLock()
	calls = mock.calls.Decimals
	lockCoinMockDecimals.RUnlock()
	return calls
}

// FormatAmount calls FormatAmountFunc.
func (mock *CoinMock) FormatAmount(amount coin.Amount, isFee bool) string {
	if mock.FormatAmountFunc == nil {
		panic("CoinMock.FormatAmountFunc: method is nil but Coin.FormatAmount was just called")
	}
	callInfo := struct {
		Amount coin.Amount
		IsFee  bool
	}{
		Amount: amount,
		IsFee:  isFee,
	}
	lockCoinMockFormatAmount.Lock()
	mock.calls.FormatAmount = append(mock.calls.FormatAmount, callInfo)
	lockCoinMockFormatAmount.Unlock()
	return mock.FormatAmountFunc(amount, isFee)
}

// FormatAmountCalls gets all the calls that were made to FormatAmount.
// Check the length with:
//     len(mockedCoin.FormatAmountCalls())
func (mock *CoinMock) FormatAmountCalls() []struct {
	Amount coin.Amount
	IsFee  bool
} {
	var calls []struct {
		Amount coin.Amount
		IsFee  bool
	}
	lockCoinMockFormatAmount.RLock()
	calls = mock.calls.FormatAmount
	lockCoinMockFormatAmount.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *CoinMock) Initialize() {
	if mock.InitializeFunc == nil {
		panic("CoinMock.InitializeFunc: method is nil but Coin.Initialize was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockCoinMockInitialize.Unlock()
	mock.InitializeFunc()
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedCoin.InitializeCalls())
func (mock *CoinMock) InitializeCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockCoinMockInitialize.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *CoinMock) Name() string {
	if mock.NameFunc == nil {
		panic("CoinMock.NameFunc: method is nil but Coin.Name was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	lockCoinMockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedCoin.NameCalls())
func (mock *CoinMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockName.RLock()
	calls = mock.calls.Name
	lockCoinMockName.RUnlock()
	return calls
}

// Observe calls ObserveFunc.
func (mock *CoinMock) Observe(in1 func(observable.Event)) func() {
	if mock.ObserveFunc == nil {
		panic("CoinMock.ObserveFunc: method is nil but Coin.Observe was just called")
	}
	callInfo := struct {
		In1 func(observable.Event)
	}{
		In1: in1,
	}
	lockCoinMockObserve.Lock()
	mock.calls.Observe = append(mock.calls.Observe, callInfo)
	lockCoinMockObserve.Unlock()
	return mock.ObserveFunc(in1)
}

// ObserveCalls gets all the calls that were made to Observe.
// Check the length with:
//     len(mockedCoin.ObserveCalls())
func (mock *CoinMock) ObserveCalls() []struct {
	In1 func(observable.Event)
} {
	var calls []struct {
		In1 func(observable.Event)
	}
	lockCoinMockObserve.RLock()
	calls = mock.calls.Observe
	lockCoinMockObserve.RUnlock()
	return calls
}

// SmallestUnit calls SmallestUnitFunc.
func (mock *CoinMock) SmallestUnit() string {
	if mock.SmallestUnitFunc == nil {
		panic("CoinMock.SmallestUnitFunc: method is nil but Coin.SmallestUnit was just called")
	}
	callInfo := struct {
	}{}
	lockCoinMockSmallestUnit.Lock()
	mock.calls.SmallestUnit = append(mock.calls.SmallestUnit, callInfo)
	lockCoinMockSmallestUnit.Unlock()
	return mock.SmallestUnitFunc()
}

// SmallestUnitCalls gets all the calls that were made to SmallestUnit.
// Check the length with:
//     len(mockedCoin.SmallestUnitCalls())
func (mock *CoinMock) SmallestUnitCalls() []struct {
} {
	var calls []struct {
	}
	lockCoinMockSmallestUnit.RLock()
	calls = mock.calls.SmallestUnit
	lockCoinMockSmallestUnit.RUnlock()
	return calls
}

// ToUnit calls ToUnitFunc.
func (mock *CoinMock) ToUnit(amount coin.Amount, isFee bool) float64 {
	if mock.ToUnitFunc == nil {
		panic("CoinMock.ToUnitFunc: method is nil but Coin.ToUnit was just called")
	}
	callInfo := struct {
		Amount coin.Amount
		IsFee  bool
	}{
		Amount: amount,
		IsFee:  isFee,
	}
	lockCoinMockToUnit.Lock()
	mock.calls.ToUnit = append(mock.calls.ToUnit, callInfo)
	lockCoinMockToUnit.Unlock()
	return mock.ToUnitFunc(amount, isFee)
}

// ToUnitCalls gets all the calls that were made to ToUnit.
// Check the length with:
//     len(mockedCoin.ToUnitCalls())
func (mock *CoinMock) ToUnitCalls() []struct {
	Amount coin.Amount
	IsFee  bool
} {
	var calls []struct {
		Amount coin.Amount
		IsFee  bool
	}
	lockCoinMockToUnit.RLock()
	calls = mock.calls.ToUnit
	lockCoinMockToUnit.RUnlock()
	return calls
}

// Unit calls UnitFunc.
func (mock *CoinMock) Unit(isFee bool) string {
	if mock.UnitFunc == nil {
		panic("CoinMock.UnitFunc: method is nil but Coin.Unit was just called")
	}
	callInfo := struct {
		IsFee bool
	}{
		IsFee: isFee,
	}
	lockCoinMockUnit.Lock()
	mock.calls.Unit = append(mock.calls.Unit, callInfo)
	lockCoinMockUnit.Unlock()
	return mock.UnitFunc(isFee)
}

// UnitCalls gets all the calls that were made to Unit.
// Check the length with:
//     len(mockedCoin.UnitCalls())
func (mock *CoinMock) UnitCalls() []struct {
	IsFee bool
} {
	var calls []struct {
		IsFee bool
	}
	lockCoinMockUnit.RLock()
	calls = mock.calls.Unit
	lockCoinMockUnit.RUnlock()
	return calls
}
