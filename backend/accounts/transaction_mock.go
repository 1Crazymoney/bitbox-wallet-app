// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package accounts

import (
	"github.com/digitalbitbox/bitbox-wallet-app/backend/coins/coin"
	"sync"
	"time"
)

var (
	lockTransactionMockAddresses                sync.RWMutex
	lockTransactionMockAmount                   sync.RWMutex
	lockTransactionMockFee                      sync.RWMutex
	lockTransactionMockInternalID               sync.RWMutex
	lockTransactionMockNumConfirmations         sync.RWMutex
	lockTransactionMockNumConfirmationsComplete sync.RWMutex
	lockTransactionMockStatus                   sync.RWMutex
	lockTransactionMockTimestamp                sync.RWMutex
	lockTransactionMockTxID                     sync.RWMutex
	lockTransactionMockType                     sync.RWMutex
)

// Ensure, that TransactionMock does implement Transaction.
// If this is not the case, regenerate this file with moq.
var _ Transaction = &TransactionMock{}

// TransactionMock is a mock implementation of Transaction.
//
//     func TestSomethingThatUsesTransaction(t *testing.T) {
//
//         // make and configure a mocked Transaction
//         mockedTransaction := &TransactionMock{
//             AddressesFunc: func() []AddressAndAmount {
// 	               panic("mock out the Addresses method")
//             },
//             AmountFunc: func() coin.Amount {
// 	               panic("mock out the Amount method")
//             },
//             FeeFunc: func() *coin.Amount {
// 	               panic("mock out the Fee method")
//             },
//             InternalIDFunc: func() string {
// 	               panic("mock out the InternalID method")
//             },
//             NumConfirmationsFunc: func() int {
// 	               panic("mock out the NumConfirmations method")
//             },
//             NumConfirmationsCompleteFunc: func() int {
// 	               panic("mock out the NumConfirmationsComplete method")
//             },
//             StatusFunc: func() TxStatus {
// 	               panic("mock out the Status method")
//             },
//             TimestampFunc: func() *time.Time {
// 	               panic("mock out the Timestamp method")
//             },
//             TxIDFunc: func() string {
// 	               panic("mock out the TxID method")
//             },
//             TypeFunc: func() TxType {
// 	               panic("mock out the Type method")
//             },
//         }
//
//         // use mockedTransaction in code that requires Transaction
//         // and then make assertions.
//
//     }
type TransactionMock struct {
	// AddressesFunc mocks the Addresses method.
	AddressesFunc func() []AddressAndAmount

	// AmountFunc mocks the Amount method.
	AmountFunc func() coin.Amount

	// FeeFunc mocks the Fee method.
	FeeFunc func() *coin.Amount

	// InternalIDFunc mocks the InternalID method.
	InternalIDFunc func() string

	// NumConfirmationsFunc mocks the NumConfirmations method.
	NumConfirmationsFunc func() int

	// NumConfirmationsCompleteFunc mocks the NumConfirmationsComplete method.
	NumConfirmationsCompleteFunc func() int

	// StatusFunc mocks the Status method.
	StatusFunc func() TxStatus

	// TimestampFunc mocks the Timestamp method.
	TimestampFunc func() *time.Time

	// TxIDFunc mocks the TxID method.
	TxIDFunc func() string

	// TypeFunc mocks the Type method.
	TypeFunc func() TxType

	// calls tracks calls to the methods.
	calls struct {
		// Addresses holds details about calls to the Addresses method.
		Addresses []struct {
		}
		// Amount holds details about calls to the Amount method.
		Amount []struct {
		}
		// Fee holds details about calls to the Fee method.
		Fee []struct {
		}
		// InternalID holds details about calls to the InternalID method.
		InternalID []struct {
		}
		// NumConfirmations holds details about calls to the NumConfirmations method.
		NumConfirmations []struct {
		}
		// NumConfirmationsComplete holds details about calls to the NumConfirmationsComplete method.
		NumConfirmationsComplete []struct {
		}
		// Status holds details about calls to the Status method.
		Status []struct {
		}
		// Timestamp holds details about calls to the Timestamp method.
		Timestamp []struct {
		}
		// TxID holds details about calls to the TxID method.
		TxID []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
}

// Addresses calls AddressesFunc.
func (mock *TransactionMock) Addresses() []AddressAndAmount {
	if mock.AddressesFunc == nil {
		panic("TransactionMock.AddressesFunc: method is nil but Transaction.Addresses was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockAddresses.Lock()
	mock.calls.Addresses = append(mock.calls.Addresses, callInfo)
	lockTransactionMockAddresses.Unlock()
	return mock.AddressesFunc()
}

// AddressesCalls gets all the calls that were made to Addresses.
// Check the length with:
//     len(mockedTransaction.AddressesCalls())
func (mock *TransactionMock) AddressesCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockAddresses.RLock()
	calls = mock.calls.Addresses
	lockTransactionMockAddresses.RUnlock()
	return calls
}

// Amount calls AmountFunc.
func (mock *TransactionMock) Amount() coin.Amount {
	if mock.AmountFunc == nil {
		panic("TransactionMock.AmountFunc: method is nil but Transaction.Amount was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockAmount.Lock()
	mock.calls.Amount = append(mock.calls.Amount, callInfo)
	lockTransactionMockAmount.Unlock()
	return mock.AmountFunc()
}

// AmountCalls gets all the calls that were made to Amount.
// Check the length with:
//     len(mockedTransaction.AmountCalls())
func (mock *TransactionMock) AmountCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockAmount.RLock()
	calls = mock.calls.Amount
	lockTransactionMockAmount.RUnlock()
	return calls
}

// Fee calls FeeFunc.
func (mock *TransactionMock) Fee() *coin.Amount {
	if mock.FeeFunc == nil {
		panic("TransactionMock.FeeFunc: method is nil but Transaction.Fee was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockFee.Lock()
	mock.calls.Fee = append(mock.calls.Fee, callInfo)
	lockTransactionMockFee.Unlock()
	return mock.FeeFunc()
}

// FeeCalls gets all the calls that were made to Fee.
// Check the length with:
//     len(mockedTransaction.FeeCalls())
func (mock *TransactionMock) FeeCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockFee.RLock()
	calls = mock.calls.Fee
	lockTransactionMockFee.RUnlock()
	return calls
}

// InternalID calls InternalIDFunc.
func (mock *TransactionMock) InternalID() string {
	if mock.InternalIDFunc == nil {
		panic("TransactionMock.InternalIDFunc: method is nil but Transaction.InternalID was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockInternalID.Lock()
	mock.calls.InternalID = append(mock.calls.InternalID, callInfo)
	lockTransactionMockInternalID.Unlock()
	return mock.InternalIDFunc()
}

// InternalIDCalls gets all the calls that were made to InternalID.
// Check the length with:
//     len(mockedTransaction.InternalIDCalls())
func (mock *TransactionMock) InternalIDCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockInternalID.RLock()
	calls = mock.calls.InternalID
	lockTransactionMockInternalID.RUnlock()
	return calls
}

// NumConfirmations calls NumConfirmationsFunc.
func (mock *TransactionMock) NumConfirmations() int {
	if mock.NumConfirmationsFunc == nil {
		panic("TransactionMock.NumConfirmationsFunc: method is nil but Transaction.NumConfirmations was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockNumConfirmations.Lock()
	mock.calls.NumConfirmations = append(mock.calls.NumConfirmations, callInfo)
	lockTransactionMockNumConfirmations.Unlock()
	return mock.NumConfirmationsFunc()
}

// NumConfirmationsCalls gets all the calls that were made to NumConfirmations.
// Check the length with:
//     len(mockedTransaction.NumConfirmationsCalls())
func (mock *TransactionMock) NumConfirmationsCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockNumConfirmations.RLock()
	calls = mock.calls.NumConfirmations
	lockTransactionMockNumConfirmations.RUnlock()
	return calls
}

// NumConfirmationsComplete calls NumConfirmationsCompleteFunc.
func (mock *TransactionMock) NumConfirmationsComplete() int {
	if mock.NumConfirmationsCompleteFunc == nil {
		panic("TransactionMock.NumConfirmationsCompleteFunc: method is nil but Transaction.NumConfirmationsComplete was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockNumConfirmationsComplete.Lock()
	mock.calls.NumConfirmationsComplete = append(mock.calls.NumConfirmationsComplete, callInfo)
	lockTransactionMockNumConfirmationsComplete.Unlock()
	return mock.NumConfirmationsCompleteFunc()
}

// NumConfirmationsCompleteCalls gets all the calls that were made to NumConfirmationsComplete.
// Check the length with:
//     len(mockedTransaction.NumConfirmationsCompleteCalls())
func (mock *TransactionMock) NumConfirmationsCompleteCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockNumConfirmationsComplete.RLock()
	calls = mock.calls.NumConfirmationsComplete
	lockTransactionMockNumConfirmationsComplete.RUnlock()
	return calls
}

// Status calls StatusFunc.
func (mock *TransactionMock) Status() TxStatus {
	if mock.StatusFunc == nil {
		panic("TransactionMock.StatusFunc: method is nil but Transaction.Status was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockStatus.Lock()
	mock.calls.Status = append(mock.calls.Status, callInfo)
	lockTransactionMockStatus.Unlock()
	return mock.StatusFunc()
}

// StatusCalls gets all the calls that were made to Status.
// Check the length with:
//     len(mockedTransaction.StatusCalls())
func (mock *TransactionMock) StatusCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockStatus.RLock()
	calls = mock.calls.Status
	lockTransactionMockStatus.RUnlock()
	return calls
}

// Timestamp calls TimestampFunc.
func (mock *TransactionMock) Timestamp() *time.Time {
	if mock.TimestampFunc == nil {
		panic("TransactionMock.TimestampFunc: method is nil but Transaction.Timestamp was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockTimestamp.Lock()
	mock.calls.Timestamp = append(mock.calls.Timestamp, callInfo)
	lockTransactionMockTimestamp.Unlock()
	return mock.TimestampFunc()
}

// TimestampCalls gets all the calls that were made to Timestamp.
// Check the length with:
//     len(mockedTransaction.TimestampCalls())
func (mock *TransactionMock) TimestampCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockTimestamp.RLock()
	calls = mock.calls.Timestamp
	lockTransactionMockTimestamp.RUnlock()
	return calls
}

// TxID calls TxIDFunc.
func (mock *TransactionMock) TxID() string {
	if mock.TxIDFunc == nil {
		panic("TransactionMock.TxIDFunc: method is nil but Transaction.TxID was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockTxID.Lock()
	mock.calls.TxID = append(mock.calls.TxID, callInfo)
	lockTransactionMockTxID.Unlock()
	return mock.TxIDFunc()
}

// TxIDCalls gets all the calls that were made to TxID.
// Check the length with:
//     len(mockedTransaction.TxIDCalls())
func (mock *TransactionMock) TxIDCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockTxID.RLock()
	calls = mock.calls.TxID
	lockTransactionMockTxID.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *TransactionMock) Type() TxType {
	if mock.TypeFunc == nil {
		panic("TransactionMock.TypeFunc: method is nil but Transaction.Type was just called")
	}
	callInfo := struct {
	}{}
	lockTransactionMockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	lockTransactionMockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedTransaction.TypeCalls())
func (mock *TransactionMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	lockTransactionMockType.RLock()
	calls = mock.calls.Type
	lockTransactionMockType.RUnlock()
	return calls
}
